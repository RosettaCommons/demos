#!/usr/bin/env python2.7
##-*- mode:python;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t;python-indent:2 -*-'
###
###
### This file is part of the CS-Rosetta Toolbox and is made available under
### GNU General Public License
### Copyright (C) 2011-2012 Oliver Lange
### email: oliver.lange@tum.de
### web: www.csrosetta.org
###
### This program is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program.  If not, see <http://www.gnu.org/licenses/>.
###
###

#from sys import argv,stderr,exit
#import sys
from os.path import basename
from os import path
import traceback
import argparse
import sys
import os
import shutil
from glob import glob
import subprocess
### toolbox library
try:
	from library import LibException, MissingInput
	import library
	from ExampleArgumentParser import ExampleArgumentParser
except ImportError as exc:
	traceback.print_exc(exc)
	print "\ncall 'source %s/init'"%path.dirname(__file__)
	print "before using the toolbox or put this call into your .bashrc"
	exit()


parser = ExampleArgumentParser(prog=basename(__file__), description="write multi-model PDB file as as individual pdb - structures ",
examples=[('%(prog)s all.pdb','write individual models as model_01.pdb, model_02.pdb, ...'),
          ('%(prog)s -silent some.out','use silent file for input, output model names will be decoy-tags'),
					('cat all.pdb | %(prog)s -remark ROSETTA-TAG','use name in REMARK field generated by pack_pdbs for pdb filename')])

#add special options that are only relevant for setup_run
parser.add_argument("-s", help="input pdb structure", default="stdin")
parser.add_argument("pdb", nargs="?", help="input pdb structure", default="stdin" )
parser.add_argument("-silent", help="read models from silent file", default=None)
parser.add_argument("-zeros", help="amount of 0 padding for output name", default=2, type=int)
parser.add_argument("-remark", help="use remark with keyword to figure out name", default=None)

library.add_standard_args( parser )

#parse cmd-line and check usage
args = parser.parse_args()

#start the main program
try:
	fmt_string="%(fbase)s_%(model)0"+("%d"%args.zeros)+"d.pdb"
#output:
	verbose=1
	if args.pdb!="stdin" or args.s!="stdin":
		if args.silent:
			exit("Error: it is not allowed to specify -s and -silent at the same time")
		if args.pdb!="stdin":
			name=args.pdb
		else:
			name=args.s
		if args.s!="stdin" and args.pdb!="stdin":
			exit("if -s you cannot also have a positional argument")
		infile=open(name,'r');
		fbase=path.splitext(basename(name))[0]
	else:
		infile=sys.stdin
		fbase='model'

####### program start
	if verbose:
		library.hello( __file__ )
	if args.silent:
		prog=library.rosetta_executable( 'extract_pdbs' )
		if verbose:
			print 'Read silent file: %s...'%args.silent
		subprocess.call( '%s -in:file:silent %s -out:level 200'%(prog,args.silent), shell=True )
		exit(0)

	model = -1
	pdb_lines=[]
	for line in infile:
		tags= line.split()
		if not len(tags): continue
		if tags[0] == "MODEL":
			if len(pdb_lines):
				output = open(fmt_string%locals(), 'w')
				for p in pdb_lines:
					output.write(p)
				pdb_lines=[]
			model = int(tags[1])
			continue
		if tags[0] =="REMARK" and args.remark:
			if args.remark in tags:
				fmt_string='%s.pdb'%tags[tags.index(args.remark)+1]
				continue
		if model >= 0:
			pdb_lines.append(line)

	if len(pdb_lines):
		output = open(fmt_string%locals(), 'w')
		for p in pdb_lines:
			output.write(p)



except LibException as inst:
	if args.traceback:
		print traceback.print_exc(inst )
	else:
		print traceback.print_exception(sys.exc_type, sys.exc_value, None)
	exit(1)
